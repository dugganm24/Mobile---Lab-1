__Project Setup__
Setting up this project for further development was a straightforward process. The first step is to download Android Studio Installer for the correct operating system (in this case for MacOS). After installing and configuring Android Studio with the default settings and SDK components provided in the installer, open the Android Studio App. In Android Studio, there is a dropdown in the top left corner where you can create a new project, open an existing project, or clone a repository. Select clone repository, and enter the URL for the architecture-samples project repository (https://github.com/android/architecture-samples) and select clone. After cloning, the user is able to compile and run the app with no difficulties. This is due to the fact that the project uses Gradle for dependency management, which automatically fetches and resolves any dependencies required by the project. Dependencies that this project needs include Compose for UI development, Room for the database, Hilt for dependency injection, and Kotlin Coroutines and Flow for asynchronous operations. Gradle was able to resolve all dependencies without any user action, and Gradle wrapper was used to ensure the correct version was automatically downloaded. Building the project using a Medium Phone API 36 emulator was successful without encountering any issues. 

__App Overview__
The Todo app is a sample application used to demonstrate best practices in Android development, and its main purpose is to provide a simple todo list. There are several main functionalities of this app, including the ability to add and edit tasks, view details of a specific task, filter tasks based on completion status, mark a task as completed, delete tasks, and view the statistics of their tasks (percentage completed and percentage active). The app is able to implement this functionality through the Model-View-ViewModel (MVVM) archictecture. The Model (data) layer uses Room for data storage and has a single task table with columns for taskId (primary key), title, description, and isCompleted. The DefaultTaskRepository.kt acts as an entry point for managing task's data. The View (UI) layer is built using Compose, which is Android's UI toolkit. ViewModel acts as the middle man between the View and Model, showing the UI state using StateFlow and handling user interactions, along with ViewModelScope to handle any coroutines. Other key technologies used in this app include Hilt for dependency injection, and Kotlin Coroutines and Flow for asynchronous operations. Navigation is managed through the TodoNavGraph.kt and TodoNavigation.kt files. In this system, TodoNavGraph.kt defines the navigation graph and routes between screens, and TodoNavigation.kt provides necessary helper functions to TodoNavGraph.kt for navigating between screens. The application has screens for displaying the task list, individual task details, adding/editing tasks, and viewing statistics about task completion. Application initialization is handled through TodoActivity.kt, which sets the app's theme to TodoThem and calls TodoNavGraph() to handle navigation between screens, and TodoApplication.kt, which initializes Hilt for dependency injection and uses Timber for logging. 

__Key Feature 1: Adding/Editing Tasks__
The first key feature to highlight is the ability to add and edit tasks. To overview the high level functionality of this feature, a user can select the plus button on the bottom right corner of the app which brings a user to the add/edit screen where a user can add a title and a description to the task, and after clicking the check mark button in the bottom right the task is saved and the user is sent back to the tasks list screen. This functionality is implemented in two main files, AddEditTaskScreen.kt and AddEditTaskViewModel.kt. 

AddEditTaskScreen.kt represents the View, or UI, layer of this component. This file implements the AddEditTaskScreen composable, which fegines the UI through a Scaffold structure, and it includes a top app bar through AddEditTaskTopAppBar, a floating action button (FAB) for saving tasks, and a SnackbarHost for displaying user messages. The main content of the screen is rendered by the AddEditTaskContent composable. This composable displays two OutlinedTextField elements, for the title and description of the task. These allow for the user to input or modify the title and description of a task. The SmallFloatingActionButton calls saceTask() from AddEditTaskViewModel when clicked. 

AddEditTaskViewModel.kt represents the ViewModel layer, which is the middle component between the View and Model layers of the app. This file implements AddEditTaskViewModel, which manages the state and logic for the UI. It uses MutableStateFlow for the UI state, which includes a title and description for the task, loading status, user messages, and the isTaskSaved flag. To highlight the flow of this file, initialization begins with ViewModel getting the taskId from SavedStateHandle. From there, if this taskId is provided it loads the details from the repository with loadTask(). saveTask() is implemented next, which is called when the user clicks the save button in the front end. This function first checks if the title or description is empty, and throws a snackbar message that these fields cannot be empty. If the input is valid, it proceeds to call createNewTask() or updateTask() dependent upon if taskId exists previously. createNewTask() creates a new task in the repository, then sets isTaskSaved to true, and updateTask() has the same functionality but updates an existing task. This file also implements functions like updateTitle() and updateDescription() to update these fields in the UI state. The final function defined in this is loadTask(), which gets task details from the repository with getTask() and updates the UI with these details. The final aspect to highlight is that this ViewModel uses viewModelScope.launch to perform asynchronous operations like saving and loading tasks, and uses StateFlow to manage the UI state and update the UI.

This component interacts with the Model, or data, layer through AddEditTaskViewModel as well. This file interacts with the TaskRepository, which has functions for creating, updating, and getting tasks from the database. This repository works with the Room database through the DAO to perform these operations.

__Key Feature 2 Viewing Task Details__
The second key feature to highlight is the ability to view task details in the tasks lists. To overview the high level functionality of this feature, a user can  select a task from the tasks list which brings them to the task details screen, which displays the title, description, and completion status of the task. It also offers options to edit or delete the task. This functionality is implemented in two main files, TaskDetailScreen.kt and TaskDetailViewModel.kt.

TaskDetailScreen.kt represents the View, or UI, layer of this component. This file implements the TaskDetailScreen composable, which defines the UI through a Scaffold structure. It includes TaskDetailTopAppBar to represent the topapp bar, a floating action button for editing the task, and a SnackbarHost for displaying user messages. The main content of this screen is rendered by the EditTaskContent composable, which displays the title, description, and completion status with Text and Checkbox components. The SmallFloatingActionButton calls onEditTask, which navigates to the edit task screen with the current task ID. 

TasDetailViewModel.kt represents the ViewModel layer, which is the middle man between the View and Model layers of this component of the app. This file implements TaskDetailViewModel, which manages the state and logic for the UI. It uses StateFlow to show the UI state, which includes task details, loading status, user messages, and a flag to indicate if the task has been deleted or not. To highlight the flow of this file, initialization begins with the ViewModel getting taskId from SavedStateHandle. From there, it gets the task details thorugh taskRepository.getTaskStream(). The combine operator is used to transfomr the Flow of task data into a StateFlow, which emits updates whenever any of the task details change. The handleTask() function is used to map the task data to an Async state, which can be loading, success, or error. The deleteTask() function calls taskRepository.deleteTask() to delete the task and sets isTaskDeleted to true to navigate back to the tasks list. setCompleted() calls taskRepository.completeTask() or taskRepository.activateTask() to update the task's completion status, then displays a snackbar message to indicate to the user the new status of the task. refresh() calls taskRepository.refreshTask() to refresh the task data and updates isLoading to indicate the loading status. The snackbarMessageShown() and showSnackbarMessage() functions are used to manage the display of functions. This ViewModel also uses viewModelScope.launch to perform asynchronous functions like deleting and refreshing tasks, and StateFlow to manage the UI state and update the UI.

This component also interacts with the Model (data) layer through TakDetailViewModel.kt. This file interacts with the TaskRepository, which includes functions to interact with the tasks table in the database. The reposotiy interacts with the Room database through the DAO to perform the database operations. 